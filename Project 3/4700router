#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math

class Router:

    relations = {}
    sockets = {}
    ports = {}
    # Dictionary to maintain our forwarding table
    forwarding_table = {}
    # List to maintain the cache of announcements recieved by the router
    announcement_cache = []

    def __init__(self, asn, connections):
        '''
        This is the constructor for our class Router Object. 
        It is able to initialize this router object with the provided AS Number, 
        as well as the list of connections to neighboring routers. 
        It then sets up communication channels with each neighbor through UDP sockets. 
        The port, numbers, relations, and sockets of each neighbor are stored as attributes of the router object.
        Sends handshake message to each neighbor neighbor router to establish communication.
        Params:
            @asn: Autonomous System Number
            @Connections: List of strings representing connections to other routers
        '''
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        self.connections = connections 
        
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        '''
        Modifies the given destination IP address into a new IP address.
        This new IP address comes in dotted quad notation. This is the format expected from the IP addresses.
        Params:
            @dst: Destination IP address
        Returns:
            Modified Quad Ip address
        '''
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        '''
        This function is responsible for sending a message to a specified to network using UDP socket. 
        Params:
            @network: Represents the destination network that want to send message to
            @message: Is the message to be sent to the destination network
        '''
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def run(self):
        '''
        This function is what runs our router object.
        '''
        while True:
            # Selects sockets that are ready for reading
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            # Iterates over the sockets that we know are ready for reading
            for conn in socks:
                # Recieves message from the current socket.
                # k = recieved data, addr = address of the sender
                k, addr = conn.recvfrom(65535)
                # Stores the source interface which the message was recieved
                srcif = None
                # Iterate through the sockets that are stored
                for sock in self.sockets:
                    # If the current socket is the same socket as the one which message was recieved
                    if self.sockets[sock] == conn:
                        # If it is then the srcif = current socket 
                        srcif = sock
                        break
                # Decodes the recieved message
                msg = k.decode('utf-8')
                # Print a message recieved message from the source interface
                print("Received message '%s' from %s" % (msg, srcif))
                
                try:
                    # Load the message into a json object
                    msg = json.loads(msg)

                    # Handle the message according to the message type
                    self.handle_msg(msg, srcif)
                    
                except Exception as e:
                    print('**ERROR** parsing message: %s' % e)
    
    
    def handle_msg(self, msg, srcif):
        '''
        This function takes messages recieved from the neighboring routers &
        handles them according to the message type.
        Params:
            @msg: The message recieved from the neighboring routers
        '''
        msg_type = msg.get('type')

        if msg_type == 'update':
            self.handle_update(msg)
        elif msg_type == 'withdraw':
            self.handle_withdraw(msg)
        elif msg_type == 'data':
            self.handle_data(msg)
        elif msg_type == 'dump':
            self.handle_dump(msg)
        else:
            raise ValueError(f'Message type error: {msg_type}')

    def converting_to_binary(self, address):
        '''
        This function is responsible for converting the given IP address
        into its corresponding binary notation.
        Params:
            @address: The IP address to be converted
        Returns: The converted IP address in binary notation
        '''
        # Split the address into its quads
        subnet_split = address.split('.')
        converted_address = ""
        # Iterate through the quads
        for i in subnet_split:
            binary = ""
            # Convert the quad into an integer
            decimal = int(i)
            # While the decimal is not zero
            while decimal > 0:
                # Convert the decimal into binary
                binary = str(decimal % 2) + binary
                decimal = decimal // 2
            # If the binary number is less than 8 bits long, add leading zeros
            binary = binary.zfill(8)
            converted_address += str(binary)
        # Return the converted subnet
        return converted_address
    
    def converting_to_cidr(self, subnet_mask, ip_address):
        '''
        This function is responsible for converting given ip address, and subnet mask into
        their corresponding CIDR notation.
        Params:
            @subnet_mask: The subnet mask of the ip address
            @ip_address: The network IP address
        Returns: The formatted CIDR address
        '''
        # Figure out subnet mask CIDR prefix
        converted_subnet = self.converting_to_binary(subnet_mask)
        consecutive_ones = 0
        # Count the number of consecutive ones in the subnet mask
        for i in converted_subnet:
            if i == '1':
                consecutive_ones += 1
            else:
                break 
        # Form the CIDR address
        CIDR_address = ip_address + "/" + str(consecutive_ones)
        # Return the CIDR address
        return CIDR_address
    
    def figure_out_range(self, CIDR_address):
        '''
        This function is responsible for figuring out the range of IP addresses.
        Params:
            @CIDR_address: The CIDR address
        Returns: A list containing the range of IP addresses
        '''
        # Isolate the ip address from the CIDR notation
        ip_address = CIDR_address.split('/')[0]
        # Isolate the CIDR from the CIDR notation
        cidr = int(CIDR_address.split('/')[1])
        # Figure out the number of host bits
        host_bits = 32 - cidr
        # Able to convert the ip address into a 32-bit unsigned integer
        i = struct.unpack('>I', struct.pack('!4B', *[int(x) for x in ip_address.split('.')]))[0]
        # Figure out the start of the range
        start = (i >> host_bits) << host_bits
        # Figure out the end of the range
        end = start | ((1 << host_bits) - 1)
        subnet_addresses = []
        # Iterate through the range of IP addresses
        for i in range(start, end + 1):
            subnet_addresses.append('.'.join(str((i >> (8 * j)) & 255) for j in range(3, -1, -1)))
        # Return the range of IP addresses
        return subnet_addresses
    


    def aggregation(self, entry1, entry2):
        '''
        This function handles the process of aggregating the given data. 
        It does this by looking at the following conditions:
        (1) Adjacent numerically
        (2) Forward to the same next-hop router
        (3) Have the same attributes then the two entries can be aggregated into
        a single entry
        '''
        # -- (1) Adjacent numerically --
        range1 = self.figure_out_range(entry1)
        range2 = self.figure_out_range(entry2)
        adjacent_numerically = self.are_cidr_addresses_adjacent(range1, range2)

        # -- (2) Forward to the same next-hop router --
        # Checking to see if they have the same next-hop router
        same_next_hop = False

        # -- (3) Have the same attributes then the two entries can be aggregated into a single entry -- 
        # returns True if any entries within a Network CIDR have the same attributes
        # also returns the specific network CIDRs that contain src_ip's with the same attributes
        same_attributes, _ = self.same_attributes(self.forwarding_table)


        
        # Checking to see if all of the conditions are true
        if same_attributes and adjacent_numerically and same_next_hop == True:
            return True
        else:
            return False

    def are_cidr_addresses_adjacent(self, range1, range2):
        '''
        This function is responsible for checking if the given CIDR addresses are adjacent.
        Params:
            @range1: The range of IP addresses for the first CIDR address
            @range2: The range of IP addresses for the second CIDR address
        Returns: Boolean depending on if the CIDR addresses are adjacent
        '''
        # Last IP of range1 + 1
        end1 = self.increment_ip(range1[-1])
        # Last IP of range2 + 1
        end2 = self.increment_ip(range2[-1])
        # Check if the last IP of range1 + 1 is the same as the first IP of range2
        # or if the last IP of range2 + 1 is the same as the first IP of range1
        if range1[0] == end2 or range2[0] == end1:
            return True
        else:
            return False
        
    def increment_ip(self, ip):
        '''
        This function is responsible for incrementing the given IP address.
        -- Helper function for are_cidr_addresses_adjacent --
        Params:
            @ip: The IP address to be incremented
        Returns: The incremented IP address
        '''
        # Split the IP address into its octets
        octets = ip.split('.')
        # Convert each octet to an integer
        octets = [int(octet) for octet in octets]
        # Increment the last octet
        octets[-1] += 1
        # Handle adding rules for IP addresses
        for i in range(len(octets) - 1, 0, -1):
            if octets[i] > 255:
                octets[i] = 0
                octets[i - 1] += 1
        # Convert the octets back to strings and join them with '.'
        new_ip = '.'.join(str(octet) for octet in octets)
        return new_ip

    def same_attributes(forwarding_table):
        """
        Test function to check if src_ip's attributes are the same within the same network
        CIDR. If they are, the src_ip's entires can be aggregated into one entry,
        return True. {See the testing_sameAttribute for testing!}
        """

        # TODO: if (3) have the same attributes == True
        
        # initialize bool to see if aggregation is possible
        can_aggregate = False
        # track the network_cidr that contains src_ip's with the same attributes
        # might be useful later, when we need to aggregate specific network CIDRs
        network_cidr_containing_same_attributes = set()

        # iterate through each network CIDR in forwarding table
        for network_cidr, src_data in forwarding_table.items():
            print(f"Network CIDR: {network_cidr}")
            print(f"Source Data: {src_data}\n")

            # create list of source IPs within the network CIDR
            src_ip = list(src_data.keys())
            # iterate through each src ip to compare their attributes
            for i in range(len(src_ip)):
                for j in range(i + 1, len(src_ip)):
                    src_ip1 = src_ip[i]
                    src_ip2 = src_ip[j]
                    print(f"COMPARING {src_ip1} and {src_ip2}")

                    # check if certain attributes are the same for both source IPs
                    # check for localpref, selfOrigin, ASPath, and origin
                    # TODO: ASSUMING THESE ARE THE ONLY ATTRIBUTES THAT MATTER
                    if src_data[src_ip1]["localpref"] == src_data[src_ip2]["localpref"] and \
                    src_data[src_ip1]["SelfOrigin"] == src_data[src_ip2]["SelfOrigin"] and \
                    src_data[src_ip1]["ASPath"] == src_data[src_ip2]["ASPath"] and \
                    src_data[src_ip1]["origin"] == src_data[src_ip2]["origin"]:
                        
                        # mark true if aggregation is possible
                        can_aggregate = True  
                        # track network_cidr that contains src_ip's with the same attributes
                        network_cidr_containing_same_attributes.add(network_cidr)
                        print(f"{src_ip1} & {src_ip2} CAN BE aggregated based on identical attributes. \n")

                    else:
                        # remains false if aggregation is not possible
                        print(f"{src_ip1} & {src_ip2} **CANNOT** be aggregated based on identical attributes. \n")

        print(f"Network CIDRs containing same attributes: {network_cidr_containing_same_attributes}\n")
        return can_aggregate, network_cidr_containing_same_attributes


    def handle_update(self, msg):
        '''
        This function handles the update message recieved from the neighboring
        routers & updates the forwarding table of the router. This updated route
        announcement is forwarded to all neighbors except the source.
        Params:
            @msg: The update message recieved from the neighboring routers
            @srcif: The source interface from which the message was recieved
        '''
        # Save a copy of this revocation
        self.announcement_cache.append(msg)
        
        # extract msg portion of update announcement
        msg_data = msg['msg']
        peer = msg['src'] # source/peer/neighbor IP of announcement
        dst = msg['dst'] # destination IP of announcement
        # store network attributes
        network_ip = msg_data['network']
        
        # convert network IP to CIDR notation
        network_cidr = self.converting_to_cidr(msg_data['netmask'], network_ip)
        netmask = msg_data['netmask']
        localpref = msg_data['localpref']
        ASPath = msg_data['ASPath']
        origin = msg_data['origin']
        selfOrigin = msg_data['selfOrigin']
        relation = self.relations[peer]
        

        # TODO: check if this is the correct logic? idk what ASPath is..
        # append router's ASN to front of ASPath
        # this is a list of ASNs that the route announcement has traversed
        if self.asn not in ASPath:
            ASPath.insert(0, self.asn)
        
        # if the network IP in the first layer of the dict, not in forwarding
        # table, add it along with paths of announcements
        if network_cidr not in self.forwarding_table:
            # FIRST LAYER
            self.forwarding_table[network_cidr] = {}
        
        # if peer/src isnt in the paths of the forwarding table, add it, and
        # update the forwarding table
        if peer not in self.forwarding_table[network_cidr]:
            # SECOND LAYER
            self.forwarding_table[network_cidr][peer] = {
                'netmask': netmask,
                'dst': dst,
                'ASPath': ASPath,
                'localpref': localpref,
                'origin': origin,
                'SelfOrigin': selfOrigin,
                'relation': relation,
                'network_ip': network_ip
            }
        # formated print for debugging
        print("**FORWARDING TABLE UPDATED**:\n" + json.dumps(self.forwarding_table, indent=4))

        # TODO: implement aggregation
        # for entry1 in self.forwarding_table:
        #     for entry2 in self.forwarding_table:
        #         if entry1 != entry2:
        #             # aggregate the entries
        #             if self.aggregation(entry1, entry2):
        #                 print(f"**AGGREGATION**: {entry1} & {entry2}")

     
        # forward update announcement to all neighbors except source IP
        for connection in self.connections:
            _, neighbor, relation = connection.split("-")
            if neighbor != msg['src']:
                # If the update is recieved by peer or provider
                if relation == "peer" or relation == "prov":
                    for entry in self.forwarding_table:
                         # Loop through the src ip addresses of the entry
                        for source in self.forwarding_table[entry]:
                            # Then only send a updates to our customers
                            if self.forwarding_table[entry][source]['relation'] == "cust": 
                                # create update route announcment to send to non-source neighbors
                                # message format based on expected test case
                                update_msg = {
                                    'msg': {
                                        'netmask': msg_data['netmask'],
                                        'ASPath': msg_data['ASPath'],
                                        'network': network_ip,
                                    },
                                    # put our IP address as the source of the announcement to be sent
                                    'src': self.our_addr(neighbor),
                                    # destination IP of the announcement, sending to our neighbor
                                    'dst': neighbor,
                                    'type': 'update'
                                }
                                # send the update announcement
                                self.send(source, json.dumps(update_msg))
                # If the update is recieved from a customer
                elif relation == "cust":
                    update_msg = {
                    'msg': {
                        'netmask': msg_data['netmask'],
                        'ASPath': msg_data['ASPath'],
                        'network': network_ip,
                    },
                    # ./rput our IP address as the source of the announcement to be sent
                    'src': self.our_addr(neighbor),
                    # destination IP of the announcement, sending to our neighbor
                    'dst': neighbor,
                    'type': 'update'
                }
                    # send the update announcement
                    self.send(neighbor, json.dumps(update_msg))
        return


    def handle_withdraw(self, msg):
        '''
        This function is for handling when there are route withdrawal messages.
        This is the case when a neighboring router may need to withdraw an announcement.
        This function in response to recieving a withdrawal message is to:
            1. Save copy of the revocation/cancellation of a statement
            2. Remove the dead entry from the forwarding table
            3. The copy that was saved, send this to other neighboring routes
        Params:
            @msg: The withdrawal message recieved 
        '''
        # Save a copy of this revocation
        self.announcement_cache.append(msg)
        # Extracting the source of the withdrawal message
        src = msg['src']
        # From the withdrawal message, extract the network and netmask
        network_removal, netmask_removal = [(i['network'], i['netmask']) for i in msg['msg']][0]
        # Iterate through the forwarding table
        for entry in self.forwarding_table:
            ip_address = entry.split('/')[0]
            # If the network is in the forwarding table
            if ip_address == network_removal:
                # Iterate through the paths of the forwarding table
                for j in self.forwarding_table[entry]:
                    # If the path is the same as the source of the withdrawal message
                    if j == src:
                        # If the netmask is the same as the netmask of the withdrawal message
                        if self.forwarding_table[entry][j]['netmask'] == netmask_removal:
                            # Remove the path from the forwarding table
                            print(f"**WITHDRAWAL**: {self.forwarding_table[entry][j]}")
                            del self.forwarding_table[entry][j]
                            break
        
        # Sending copies to other neighbors
        for connection in self.connections:
            _, neighbor, relation = connection.split("-")
            if neighbor != msg['src']:
                # If the announcement is recieved by peer or provider
                if relation == "peer" or relation == "prov":
                    # Iterate through the first layer keys of the forwarding table
                    for entry in self.forwarding_table:
                         # Loop through the src ip addresses of the entry
                        for source in self.forwarding_table[entry]:
                            # Then only send a updates to our customers
                            if self.forwarding_table[entry][source]['relation'] == "cust": 
                                # Send withdrawal message
                                withdraw_msg = {
                                    'msg': msg['msg'],
                                    # Put our IP address as the source of the announcement to be sent
                                    'src': self.our_addr(neighbor),
                                    # destination IP of the announcement, sending to our neighbor
                                    'dst': neighbor,
                                    'type': 'withdraw'
                                }
                                # Print statements for debugging purposes
                                print(f"**SENDING WITHDRAWAL MESSAGE**: {withdraw_msg}")
                                print("**FORWARDING TABLE UPDATED AFTER WITHDRAWAL**:\n" + json.dumps(self.forwarding_table, indent=4))
                                # send the withdrawal announcement
                                self.send(neighbor, json.dumps(withdraw_msg))
                # If the update is recieved from a customer
                elif relation == "cust":
                    withdraw_msg = {
                        'msg': msg['msg'],
                        # Put our IP address as the source of the announcement to be sent
                        'src': self.our_addr(neighbor),
                        # Destination IP of the announcement, sending to our neighbor
                        'dst': neighbor,
                        'type': 'withdraw'
                    }
                    # Print statements for debugging purposes 
                    print(f"**SENDING WITHDRAWAL MESSAGE**: {withdraw_msg}")
                    print("**FORWARDING TABLE UPDATED AFTER WITHDRAWAL**:\n" + json.dumps(self.forwarding_table, indent=4))
                    # send the withdrawal announcement
                    self.send(neighbor, json.dumps(withdraw_msg))
        return
             
    # def handle_data(self, msg):
    #     # Extract destination IP from data message received
    #     dst = msg['dst']
    #     src = msg['src']
    #     # Loop through forwarding table entries to find the best route
    #     for entry in self.forwarding_table:
    #         # Check if the destination IP falls within the range of this entry
    #         if dst in self.figure_out_range(entry):
    #             # Loop through the src ip addresses of the entry
    #             for ip_address in self.forwarding_table[entry]:
    #                 # Establishing the data message to be sent
    #                 data_msg = {
    #                     'src': src,
    #                     'dst': dst,
    #                     'type': 'data',
    #                     'msg': msg['msg']  # Forward the original message content
    #                 }
    #                 # Send the update announcement
    #                 self.send(ip_address, json.dumps(data_msg))
    #                 print(f"**DATA MESSAGE**: {data_msg}")
    #     # Exit the function once the message is forwarded
    #     return
    

    def handle_data(self, msg):
        # extract dst and src from data message
        dst = msg['dst']
        src = msg['src']
        
        # find best route to dst
        best_routes = self.find_best_route(dst)
        print(f"**BEST ROUTES**: {best_routes}")
        
        # case where there is no best route
        if not best_routes:
            # send no route message to src
            self.handle_no_route(src, dst)
        elif len(best_routes) == 1:
            # send data message to selected best route in list of best routes
            selected_route = best_routes[0]
            # Establishing the data message to be sent
            data_msg = {
                'src': self.our_addr(src),
                'dst': selected_route['dst'],
                'type': 'data',
                'msg': msg['msg']
            }
            # Send the update announcement
            self.send(selected_route['peer'], json.dumps(data_msg))
            print(f"**DATA MESSAGE**: {json.dumps(data_msg, indent=4)}")
        elif len(best_routes) > 1:
            # TODO: need to handle case where there are multiple best routes!!
            # tie breaker logic
            selected_route = self.handle_tie_breaker(best_routes)
            # Establishing the data message to be sent
            data_msg = {
                'src': self.our_addr(src),
                'dst': selected_route['dst'],
                'type': 'data',
                'msg': msg['msg']
            }
            # Send the update announcement
            self.send(selected_route['peer'], json.dumps(data_msg))
            print(f"**DATA MESSAGE**: {json.dumps(data_msg, indent=4)}")
            
        # Exit the function once the message is forwarded
        return


    def find_best_route(self, dst):
        '''
        This function is responsible for finding the best route to the given
        destination IP address.
        Params:
            @dst: The destination IP address
        Returns: A list of the best routes to the destination IP address
        '''
        # convert destination IP to binary
        dst_binary = self.converting_to_binary(dst)
        # initialize variables to store best routes and longest prefix match
        best_routes = []
        longest_prefix_match = -1
        
        # iterate through forwarding table to get entry and details
        for entry, details in self.forwarding_table.items():
            # iterate through the src ip addresses of the entry and their attributes
            for peer, attributes in details.items():
                # convert network IP and netmask to binary
                network_binary = self.converting_to_binary(attributes['network_ip'])
                netmask_binary = self.converting_to_binary(attributes['netmask'])
                
                # convert the network ip and netmask to perform bitwise AND operation
                mask_result = format(int(network_binary, 2) & int(netmask_binary, 2), '032b')
                
                # counter to keep track of matching bits
                count_matching_bits = 0
                
                # iterate through the mask result and destination binary to find matching bits
                for i in range(min(len(mask_result), len(dst_binary))):
                    if mask_result[i] == dst_binary[i]:
                        count_matching_bits += 1
                    else:
                        # break if there are no more matching bits
                        break
                
                # TODO: check logic here:
                # for each peer, check if the count of matching bits is greater than the longest prefix match
                # if it is, update the longest prefix match and best routes
                if count_matching_bits > longest_prefix_match:
                    longest_prefix_match = count_matching_bits
                    best_routes = [{'peer': peer, 'dst': attributes['network_ip'], 'localpref': attributes['localpref'], 'selfOrigin': attributes['SelfOrigin'], 'ASPath': attributes['ASPath'], 'origin': attributes['origin'], 'network_ip': attributes['network_ip']}]
                # if the count of matching bits is equal to the longest prefix match, append to best routes
                elif count_matching_bits == longest_prefix_match:
                    best_routes.append({'peer': peer, 'dst': attributes['network_ip'], 'localpref': attributes['localpref'], 'selfOrigin': attributes['SelfOrigin'], 'ASPath': attributes['ASPath'], 'origin': attributes['origin'], 'network_ip': attributes['network_ip']})
        
        return best_routes


    def handle_tie_breaker(self, best_routes):
        # break tie for highest localpref
        highest_localpref = -1
        route_tie_winner = []
        for route in best_routes:
            if route['localpref'] > highest_localpref:
                highest_localpref = route['localpref']
                route_tie_winner = [route]
            if route['localpref'] == highest_localpref:
                route_tie_winner.append(route)
        best_routes = route_tie_winner
        
        # break tie for selfOrigin
        
        return best_routes[0]


    def handle_no_route(self, src, dst):
        no_route_msg = {
            'src': self.our_addr(src),
            'dst': dst,
            'type': 'no_route',
            'msg': {"error": "No route found"}
        }
        self.send(src, json.dumps(no_route_msg))
        print(f"**NO ROUTE TO HOST**: {json.dumps(no_route_msg, indent=4)}")



    def handle_dump(self, msg):
        src = msg['src']  # Source of the dump request

        # Prepare a list to hold all the route entries
        table_entries = []

        # Iterate over each network in the forwarding table
        for network_cidr, peers in self.forwarding_table.items():
            for peer, details in peers.items():
                # make a copy of the ASPath to avoid modifying the original
                copy_aspath = details['ASPath'][:]
                # if the router's ASN is in the ASPath, remove it
                if copy_aspath and copy_aspath[0] == self.asn:
                    copy_aspath.pop(0)
                
                # For each peer, create an entry for the routing table
                entry = {
                    'network': network_cidr.split('/')[0],  # Extracting the network IP
                    'netmask': details['netmask'],  # Netmask of the network
                    'origin': details['origin'], 
                    'localpref': details['localpref'],
                    'ASPath': copy_aspath,  # ASPath of the route, popped the first element(our ASN)
                    'peer': peer,  # Peer from which the route was learned
                    'selfOrigin': details['SelfOrigin'],  # Whether the route was originated by this router
                }
                table_entries.append(entry)

        # Create the dump message to send back
        dump_msg = {
            'src': self.our_addr(src),  # Using the router's address towards the source of the request
            'dst': src,  # Destination is the source of the dump request
            'type': 'table',  # Indicating this is a table dump response
            'msg': table_entries  # The routing table entries
        }

        # Send the routing table dump back to the requester
        self.send(src, json.dumps(dump_msg))
        print(f"**DUMP MESSAGE SENT**: {json.dumps(dump_msg, indent=4)}")
        return


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()
