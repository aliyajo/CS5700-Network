#!/usr/bin/env python3
import argparse
import dnslib
import socket
import geoip2
import geoip2.database
from haversine import haversine
import time
import requests

REPLICA_SERVERS_INFO = {
    '45.33.55.171': 
 {
    'lat': 37.5625, 
    'long': -122.0004, 
    'country': 'US'}, 
 '170.187.142.220': 
 {
    'lat': 33.7485, 
    'long': -84.3871, 
    'country': 'US'}, 
 '213.168.249.157': 
 {
    'lat': 51.5074, 
    'long': -0.1196, 
    'country': 'GB'}, 
 '139.162.82.207': 
 {
    'lat': 35.6893, 
    'long': 139.6899, 
    'country': 'JP'}, 
 '45.79.124.209': 
 {
     'lat': 19.0748, 
     'long': 72.8856, 
     'country': 'IN'}, 
 '192.53.123.145': 
 {
    'lat': 43.6547, 
    'long': -79.3623, 
    'country': 'CA'}, 
 '192.46.221.203': 
 {
    'lat': -33.8715, 
    'long': 151.2006, 
    'country': 'AU'}
 }

class DNSServer:
    '''
    This class represents the DNS server.
    Should be able to dynamically return IP addresses based on the
    specified mapping code. 
        This mapping code is a system that maps IPs to nearby replica servers.
    '''
    def __init__(self, args):
        '''
        This is a constructor for the DNSServer class.
        '''
        # Port number to bind to, got from parsed argument
        self.port = args.port
        # CDN name, got from parsed argument
        self.name = args.name
        # DNS cache
        self.cache = {}
        # coordinate cache
        self.coord_cache = {}


    def best_server(self, addr):
        '''
        This function is responsible for determining the 
        best replica server.
        This entails determining the closest server to the client.
        Then check if the server is overloaded.
        Params:
            @addr: The address of the client
        Returns:
            The closest server
        '''
        # Determine the distances
        distances = self.determining_distances(addr)
        # Check if first element is overloaded
        for ip, _ in distances:
            print(f"* Checking server {ip} *\n")
            if self.check_overloaded(ip):
                print(f"* Server {ip} is overloaded *\n")
                continue
            else:
                print(f"* Server {ip} is not overloaded *\n")
                return ip
        # If all servers are overloaded, return the closest server
        print(f"* All servers are overloaded, returning to closest server {distances[0][0]}* \n")
        return distances[0][0]
            
    def determining_distances(self, addr):
        '''
        This function helps establish a list
        of distances between the client and the replica servers.
        Params:
            @addr: The address of the client
        Returns:
            A list containing the distances
        '''
        # Check if the address is in the cache
        if addr in self.coord_cache:
            addr_coord = self.coord_cache[addr]
        else:
            # Sending request to geojs.io to get the coordinates
            response = requests.get(f'https://get.geojs.io/v1/ip/geo/{addr}.json')
            if response.status_code == 200:
                data = response.json()
                # Extract the coordinates
                addr_coord = {'lat': float(data.get('latitude')), 'long': float(data.get('longitude'))}
                self.coord_cache[addr] = addr_coord
                print(f"** Client coordinates: {addr_coord} **")
                print(self.coord_cache)
            else:
                print(f"Error: {response.status_code}")
        # Determine the distances
        distances = [(ip, haversine((coord['lat'], coord['long']), (addr_coord['lat'], addr_coord['long']))) for ip, coord in REPLICA_SERVERS_INFO.items()]
        # Sort the distances, closest is first in the list
        distances.sort(key=lambda x: x[1])
        return distances

    def check_overloaded(self, ip):
        '''
        This function is responsible for checking if a server is overloaded.
        Params:
            @ip: The IP address of the server
        Returns:
            Boolean if the server is overloaded
        '''
        # URL to get the server info
        url = f'http://{ip}:{self.port}/get_server_info'
        metrics = {}
        try:
            # Send request to the HTTP server
            response = requests.get(url)
            metrics[ip] = response.json()
            print(f"** Server {ip} metrics: {metrics[ip]} **")
            # Check if the cpu_percent is greater than 90%
            # Or if any of the load averages are greater than 2.0
            if any([load >= 2.0 for load in metrics[ip]['load_average']]) or metrics[ip]['cpu_percent'] >= 90.0:
                return True
            else:
                return False
        except Exception as e:
            print(e)

    def run(self):
        '''
        This is the main running function for the DNS server.
        '''
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.bind(('', self.port))
        print(f' ** dns server running on port {self.port} ** ')
        
        try:
            while True:
                data, addr = s.recvfrom(1024)
                local_addr = addr[0]
                # Isolate the request
                request = dnslib.DNSRecord.parse(data)
                # Determine if the request if an A record
                # Also determine if the request is for the correct name
                if request.q.qname == self.name and request.q.qtype == dnslib.QTYPE.A:
                    # Check if in DNS cache
                    if local_addr in self.cache:
                        # Check if the cache is still valid, using timing component
                        if time.time() - self.cache[local_addr]['time'] < 300:
                            # Draft the response
                            response = request.reply()
                            response.add_answer(
                                dnslib.RR(
                                    request.q.qname, 
                                    dnslib.QTYPE.A,
                                    ttl=300, 
                                    rdata=dnslib.A(self.cache[local_addr]['ip'])))
                            s.sendto(response.pack(), addr)
                            continue
                        # If the cache is invalid, remove it
                        else:
                            del self.cache[local_addr]
                    # Determine the best server, geographically based
                    best_addr = self.best_server(local_addr)
                    # Draft the response
                    response = request.reply()
                    response.add_answer(
                        dnslib.RR(
                            request.q.qname, 
                            dnslib.QTYPE.A,
                            ttl=300, 
                            rdata=dnslib.A(best_addr)))
                    # Send the response
                    s.sendto(response.pack(), addr)
                    print(f' ** Sent response to CLIENT ADDRESS: {addr}, & RESPONSE: {response} ** ')
                    # Update the cache
                    self.cache[local_addr] = {'ip': best_addr, 'time': time.time()}
        except Exception as e:
            print(e)
        # Close the socket
        finally:
            s.close()
        

if __name__ == "__main__":
    # Parse the correct arguments
    parser = argparse.ArgumentParser(description="dnsserver")
    # Parsing for the port number, required argument
    parser.add_argument('-p', dest="port", type=int, required=True, help='Port to bind to')
    # Parsing for the CDN-specific name of the server, required argument
    parser.add_argument('-n', dest="name", type=str, required=True, help='CDN-specific name of server')
    args = parser.parse_args()
    server = DNSServer(args)
    server.run()

